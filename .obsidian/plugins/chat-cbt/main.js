/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/cryptr/index.js
var require_cryptr = __commonJS({
  "node_modules/cryptr/index.js"(exports, module2) {
    var crypto = require("crypto");
    var algorithm = "aes-256-gcm";
    var ivLength = 16;
    var tagLength = 16;
    var defaultEncoding = "hex";
    var defaultSaltLength = 64;
    var defaultPbkdf2Iterations = 1e5;
    function Cryptr2(secret, options) {
      if (!secret || typeof secret !== "string") {
        throw new Error("Cryptr: secret must be a non-0-length string");
      }
      let encoding = defaultEncoding;
      let saltLength = defaultSaltLength;
      let pbkdf2Iterations = defaultPbkdf2Iterations;
      if (options) {
        if (options.encoding) {
          encoding = options.encoding;
        }
        if (options.pbkdf2Iterations) {
          pbkdf2Iterations = options.pbkdf2Iterations;
        }
        if (options.saltLength) {
          saltLength = options.saltLength;
        }
      }
      const tagPosition = saltLength + ivLength;
      const encryptedPosition = tagPosition + tagLength;
      function getKey(salt) {
        return crypto.pbkdf2Sync(secret, salt, pbkdf2Iterations, 32, "sha512");
      }
      this.encrypt = function encrypt(value) {
        if (value == null) {
          throw new Error("value must not be null or undefined");
        }
        const iv = crypto.randomBytes(ivLength);
        const salt = crypto.randomBytes(saltLength);
        const key = getKey(salt);
        const cipher = crypto.createCipheriv(algorithm, key, iv);
        const encrypted = Buffer.concat([cipher.update(String(value), "utf8"), cipher.final()]);
        const tag = cipher.getAuthTag();
        return Buffer.concat([salt, iv, tag, encrypted]).toString(encoding);
      };
      this.decrypt = function decrypt(value) {
        if (value == null) {
          throw new Error("value must not be null or undefined");
        }
        const stringValue = Buffer.from(String(value), encoding);
        const salt = stringValue.subarray(0, saltLength);
        const iv = stringValue.subarray(saltLength, tagPosition);
        const tag = stringValue.subarray(tagPosition, encryptedPosition);
        const encrypted = stringValue.subarray(encryptedPosition);
        const key = getKey(salt);
        const decipher = crypto.createDecipheriv(algorithm, key, iv);
        decipher.setAuthTag(tag);
        return decipher.update(encrypted) + decipher.final("utf8");
      };
    }
    module2.exports = Cryptr2;
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ChatCbtPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/util/crypt.ts
var import_cryptr = __toESM(require_cryptr());
var PEPPER = [
  "Everything",
  "has",
  "been",
  "thought",
  "of",
  "before,",
  "but",
  "the",
  "problem",
  "is",
  "to",
  "think",
  "of",
  "it",
  "again"
].join("");
var crypt = new import_cryptr.default(PEPPER);

// src/util/chatcbt.ts
var import_obsidian = require("obsidian");

// src/prompts/system.ts
var system_default = `You are a Cognitive Behavioral Therapist. Your kind and open approach to CBT allows users to confide in you. You will be given an array of dialogue between the therapist and fictional user you refer to in the second person, and your task is to provide a response as the therapist. 

RESPOND TO THE USER'S LATEST PROMPT, AND KEEP YOUR RESPONSES AS BRIEF AS POSSIBLE. 

You ask questions one by one and collect the user's responses to implement the following steps of CBT :

1. Help the user identify troubling situations or conditions in their life. 

2. Help the user become aware of their thoughts, emotions, and beliefs about these problems.

3. Using the user's answers to the questions, you identify and categorize negative or inaccurate thinking that is causing the user anguish into one or more of the following CBT-defined categories:

- All-or-Nothing Thinking
- Overgeneralization
- Mental Filter
- Disqualifying the Positive
- Jumping to Conclusions
- Mind Reading
- Fortune Telling
- Magnification (Catastrophizing) or Minimization
- Emotional Reasoning
- Should Statements
- Labeling and Mislabeling
- Personalization

4. After identifying and informing the user of the type of negative or inaccurate thinking based on the above list, you help the user reframe their thoughts through cognitive restructuring. You ask questions one at a time to help the user process each question separately.

For example, you may ask:

- What evidence do I have to support this thought? What evidence contradicts it?
- Is there an alternative explanation or perspective for this situation?
- Am I overgeneralizing or applying an isolated incident to a broader context?
- Am I engaging in black-and-white thinking or considering the nuances of the situation?
- Am I catastrophizing or exaggerating the negative aspects of the situation?
- Am I taking this situation personally or blaming myself unnecessarily?
- Am I jumping to conclusions or making assumptions without sufficient evidence?
- Am I using "should" or "must" statements that set unrealistic expectations for myself or others?
- Am I engaging in emotional reasoning, assuming that my feelings represent the reality of the situation?
- Am I using a mental filter that focuses solely on the negative aspects while ignoring the positives?
- Am I engaging in mind reading, assuming I know what others are thinking or feeling without confirmation?
- Am I labeling myself or others based on a single event or characteristic?
- How would I advise a friend in a similar situation?
- What are the potential consequences of maintaining this thought? How would changing this thought benefit me?
- Is this thought helping me achieve my goals or hindering my progress?

Using the user's answers, you ask them to reframe their negative thoughts with your expert advice. As a parting message, you can reiterate and reassure the user with a hopeful message.`;

// src/prompts/summary.ts
var summary_default = `Create a markdown table summarizing the conversation. It should have columns for each negative belief mentioned by the user, emotion, category of negative thinking, and reframed thought`;

// src/util/chatcbt.ts
var SYSTEM_MSG = { role: "system", content: system_default };
var SUMMARY_MSG = { role: "user", content: summary_default };
var ChatCbt = class {
  constructor() {
  }
  async chat({
    apiKey,
    messages,
    isSummary = false,
    mode = "openai",
    ollamaUrl,
    model
  }) {
    const resolvedMsgs = [...messages];
    if (isSummary) {
      resolvedMsgs.push(SUMMARY_MSG);
    }
    let response = "";
    const msgs = [SYSTEM_MSG, ...resolvedMsgs];
    if (mode === "openai" && !!apiKey) {
      const url = "https://api.openai.com/v1/chat/completions";
      response = await this._chat(url, msgs, apiKey, model || "gpt-3.5-turbo");
    } else if (mode === "ollama" && !!ollamaUrl) {
      const url = ollamaUrl.replace(/\/$/, "") + "/v1/chat/completions";
      response = await this._chat(
        url,
        msgs,
        "ollama",
        // default API Key used by Ollama's OpenAI style chat endpoint (v0.1.24^)
        model || "mistral"
      );
    }
    return response;
  }
  async _chat(url, messages, apiKey, model) {
    const data = {
      model,
      messages,
      temperature: 0.7
    };
    const headers = {
      Authorization: `Bearer ${apiKey}`,
      "Content-Type": "application/json"
    };
    const options = {
      url,
      method: "POST",
      body: JSON.stringify(data),
      headers
    };
    const response = await (0, import_obsidian.requestUrl)(options);
    return response.json.choices[0].message.content;
  }
};

// src/constants.ts
var CHAT_AGENT_MARKER = "**ChatCBT:**";
var CHAT_DELIMETER = "\n\n---\n\n";

// src/util/parsers.ts
function escapeDangerousCharacters(str) {
  const specialCharacters = ["*", ":", "^", "$", ".", "[", "]", "|", "?", "+"];
  const split = str.split("").map((c) => {
    if (specialCharacters.includes(c)) {
      return `\\${c}`;
    } else {
      return c;
    }
  });
  return split.join("");
}

// src/util/messages.ts
function convertTextToMsg(text) {
  const agentMarkerRegex = new RegExp(
    `^${escapeDangerousCharacters(CHAT_AGENT_MARKER)}`
  );
  if (text.match(agentMarkerRegex)) {
    return {
      role: "assistant",
      content: text.replace(agentMarkerRegex, "").trim()
    };
  } else {
    return { role: "user", content: text };
  }
}
function buildAssistantMsg(text) {
  return CHAT_DELIMETER + `${CHAT_AGENT_MARKER} ${text}` + CHAT_DELIMETER;
}

// src/main.ts
var VALID_MODES = ["openai", "ollama"];
var DEFAULT_SETTINGS = {
  openAiApiKey: "",
  mode: "openai",
  model: "",
  ollamaUrl: "http://0.0.0.0:11434"
};
var chatCbt = new ChatCbt();
var ChatCbtPlugin = class extends import_obsidian2.Plugin {
  async onload() {
    console.log("loading plugin");
    await this.loadSettings();
    this.addRibbonIcon("heart-handshake", "ChatCBT", (evt) => {
      const menu = new import_obsidian2.Menu();
      menu.addItem(
        (item) => item.setTitle("Chat").setIcon("message-circle").onClick(() => {
          this.getChatCbtRepsonse({
            isSummary: false,
            mode: "openai"
          });
        })
      );
      menu.addItem(
        (item) => item.setTitle("Summarize").setIcon("table").onClick(() => {
          this.getChatCbtSummary();
        })
      );
      menu.showAtMouseEvent(evt);
    });
    this.addCommand({
      id: "chat",
      name: "Chat - submit the text in the active tab to ChatCBT",
      editorCallback: (_editor, _view) => {
        this.getChatCbtRepsonse({
          isSummary: false,
          mode: this.settings.mode
        });
      }
    });
    this.addCommand({
      id: "summarize",
      name: "Summarize - create a table that summarizes reframed thoughts from your conversation",
      editorCallback: (_editor, _view) => {
        this.getChatCbtSummary();
      }
    });
    this.addSettingTab(new MySettingTab(this.app, this));
  }
  /** Run when plugin is disabled */
  onunload() {
    console.log("unloading plugin");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async getChatCbtRepsonse({
    isSummary = false,
    mode = "openai"
  }) {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      return;
    }
    if (!VALID_MODES.includes(this.settings.mode)) {
      new import_obsidian2.Notice(
        `Inavlid mode '${this.settings.mode}' detected. Update in ChatCBT plugin settings and select a valid mode`
      );
      return;
    }
    if (this.settings.mode === "openai" && !this.settings.openAiApiKey) {
      new import_obsidian2.Notice("Missing OpenAI API Key - update in ChatCBT plugin settings");
      return;
    }
    if (this.settings.mode === "ollama" && !this.settings.ollamaUrl) {
      new import_obsidian2.Notice("Missing Ollama URL - update in ChatCBT plugin settings");
      return;
    }
    const existingText = await this.app.vault.read(activeFile);
    if (!existingText.trim()) {
      new import_obsidian2.Notice("First, share how you are feeling");
      return;
    }
    const messages = existingText.split(/---+/).map((i) => i.trim()).map((i) => convertTextToMsg(i));
    const selectedModel = this.settings.model ? this.settings.model : this.settings.mode === "openai" ? "gpt-3.5-turbo" : "mistral";
    const loadingModal = new TextModel(
      this.app,
      `Asking ChatCBT... (mode: '${this.settings.mode}', model: '${selectedModel}')`
    );
    loadingModal.open();
    let response = "";
    try {
      const apiKey = this.settings.openAiApiKey ? crypt.decrypt(this.settings.openAiApiKey) : "";
      const res = await chatCbt.chat({
        apiKey,
        messages,
        isSummary,
        mode: this.settings.mode,
        ollamaUrl: this.settings.ollamaUrl,
        model: this.settings.model
      });
      response = res;
    } catch (e) {
      let msg = e.msg;
      if (e.status === 404) {
        msg = `Model named '${this.settings.model}' not found for ${this.settings.mode}. Update mode or model name in settings.`;
      }
      new import_obsidian2.Notice(`ChatCBT failed :(: ${msg}`);
      console.error(e);
    } finally {
      loadingModal.close();
    }
    if (response) {
      const MSG_PADDING = "\n\n";
      const appendMsg = isSummary ? MSG_PADDING + response : buildAssistantMsg(response);
      await this.app.vault.append(activeFile, appendMsg);
    }
  }
  async getChatCbtSummary() {
    await this.getChatCbtRepsonse({ isSummary: true, mode: "openai" });
  }
};
var MySettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("a", {
      href: "https://github.com/clairefro/obsidian-chat-cbt-plugin/blob/main/README.md",
      text: "Read the setup guide \u2197\uFE0F "
    });
    containerEl.createEl("br");
    containerEl.createEl("br");
    new import_obsidian2.Setting(containerEl).setName("OpenAI API Key").setDesc(
      "Create an OpenAI API Key from their website and paste here (Make sure you have added credits to your account!)"
    ).addText(
      (text) => text.setPlaceholder("Enter your API Key").setValue(
        this.plugin.settings.openAiApiKey ? crypt.decrypt(this.plugin.settings.openAiApiKey) : ""
      ).onChange(async (value) => {
        if (!value.trim()) {
          this.plugin.settings.openAiApiKey = "";
        } else {
          this.plugin.settings.openAiApiKey = crypt.encrypt(value.trim());
        }
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("br");
    containerEl.createEl("br");
    new import_obsidian2.Setting(containerEl).setName("Ollama mode (local)").setDesc("Toggle on for a local experience if you are running Ollama").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.mode === "openai" ? false : true).onChange(async (value) => {
        if (value) {
          this.plugin.settings.mode = "ollama";
        } else {
          this.plugin.settings.mode = "openai";
        }
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Ollama server URL").setDesc(
      "Edit this if you changed the default port for using Ollama. Requires Ollama v0.1.24 or higher."
    ).addText(
      (text) => text.setPlaceholder("ex: http://0.0.0.0:11434").setValue(this.plugin.settings.ollamaUrl).onChange(async (value) => {
        this.plugin.settings.ollamaUrl = value.trim();
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("br");
    containerEl.createEl("br");
    new import_obsidian2.Setting(containerEl).setName("Model").setDesc(
      "For OpenAI mode the default is 'gpt-3.5-turbo' model. For Ollama mode the default is 'mistral' model. If you prefer a different model, enter it here. Delete text here to restore defaults"
    ).addText(
      (text) => text.setPlaceholder("Override model name").setValue(this.plugin.settings.model).onChange(async (value) => {
        this.plugin.settings.model = value.trim();
        await this.plugin.saveSettings();
      })
    );
  }
};
var TextModel = class extends import_obsidian2.Modal {
  constructor(app, _text) {
    super(app);
    this.text = _text;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.setText(this.text);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
